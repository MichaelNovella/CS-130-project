<!DOCTYPE html>
<html lang="en">
<head>
<style>
#content_box {
  margin: auto;
  width: 90;
 
  
}
#controls {
  margin: auto;
  width: 50%;
 text-align:center 
}
</style>

<meta charset="UTF-8">
</head>

<body onload="">
<div>

<div id="images"></div>
<canvas style="border:3px solid #000000;" id="canvas" width="1000" height="1000" onclick="place(event)"></canvas>

<div id="controls">
<button type="button" id="frognut" onclick="createGame(1000,19)">New Game: 19 Rows</button> 
<button type="button" id="frognut" onclick="createGame(1000,17)">New Game: 17 Rows</button> 
</div>
</div>
<br>
<br>
<br>
<div id="EventBox">Currently, there have been no events worth mentioning.</div>
<!--
<button type="button" id="circle" onclick="">Circle</button> 
<button type="button" id="clear" onclick="">Clear</button> 
-->
</body>
<script>
var size = 1000;
var rows = 19;
var boardPadding = 4; //value in pixels to adjust text in pieces by
var NewGame;
var runs;
var canvas = document.getElementById("canvas");
var context = canvas.getContext("2d");
var score = 0; //decide how to implement this later
var duration = 0; //implement thislater as well
function errorReport(x){
	document.getElementById("EventBox").innerHTML= "Error: " + x;
}

class piece{
	constructor(color, turn, x, y, played){
		this.color = color;
		this.turn = turn;
		this.x = x;
		this.y = y;
		this.played = played;
		
	}
}
class Game{
	constructor(size,rows){
		this.gameOver = false;
		this.size = size;
		this.rows = rows;
		this.board = new Array();
		for(let x=0;x<rows+(boardPadding*2);x+=1){
			this.board[x] = new Array(rows+(boardPadding*2)).fill(new piece(0,0,0,0,false))
		}
		this.turn = 1; //turn number
		this.color=false; //color who's turn it is, black or white, or whatever colors you pass when drawing the board.
		
	}
	play(x,y){
		if (!this.board[x+4][y+4].played){
			this.board[x+4][y+4] = new piece(this.color,this.turn,x,y,true);
			this.color = !this.color;
			this.turn +=1;
		}
		else{
		errorReport("Illegal Move, space already occupied.");
		}
	}
	getPieces(){ //this function returns two arrays, one for each color of piece
		let rows = this.rows;
		let whites = [];
		let blacks = [];
		let coords = [];
		for(let x=boardPadding-1;x<rows+boardPadding;x+=1){
			for(let y=boardPadding-1;y<rows+boardPadding;y+=1){
				if(this.board[x][y].played == true){
					coords.push(x+","+y+"| ");
					if(this.board[x][y].color == false){
						
						whites.push(this.board[x][y])
					}
					else{
						blacks.push(this.board[x][y])
					}
				}
			}
		}
		return[whites,blacks]
	}
}


function createGame(size,rows){
	NewGame = new Game(size,rows);
	var pieces = NewGame.getPieces();
	drawBoard(context, size, rows, pieces);
	
	document.body.addEventListener( 'click', function ( event ) {
		if( event.target.id == 'canvas' ) {
			if(!NewGame.gameOver){
				place(event,NewGame);
				pieces = NewGame.getPieces();
				drawBoard(context, size, rows, pieces);
				runs = getRuns(pieces,NewGame.board);
				if (runs[0][2]!=0){
					NewGame.gameOver = true;
					let winner = 0; //player one, white, 0
					gameOver(0);
					callOut(NewGame.turn-1, score, duration, winner)
				}
				if (runs[1][2]!=0){
					NewGame.gameOver = true;
					let winner = 1; //player two, black, 1
					gameOver(1);
					callOut(NewGame.turn-1, score, duration, winner)
				}
			}
		};
	});
	
}
function callOut(turn, score, duration, winner){ //This is waiting to be written either by me or my partner, this is the hook into the server side
	
}
function gameOver(){
	
}
function getRuns(pieces, board){
	var whitePotential = []; //program in potential plays later
	var white3Runs = 0;
	var white4Runs = 0;
	var white5Runs = 0;
	var blackPotential = [];
	var black3Runs = 0;
	var black4Runs = 0;
	var black5Runs = 0;
	pieces[0].forEach(element =>{ //calculates runs for white
		let x = element.x + boardPadding;
		let y = element.y + boardPadding;
		let color = element.color;
				if((board[x+1][y].played && ((board[x+1][y].color) == color)) && board[x+2][y].played && ((board[x+2][y].color) == color)){ //test for three in a row
					if((board[x+3][y].played && ((board[x+3][y].color) == color))){ //test for four in a row
						if((board[x+4][y].played && ((board[x+4][y].color) == color))){ //test for five in a row
					white5Runs+=1;
				}
				else{
					white4Runs+=1;
				}
			}
			else{
				white3Runs+=1;
			}
		}
		if((board[x][y+1].played && ((board[x][y+1].color) == color)) && board[x][y+2].played && ((board[x][y+2].color) == color)){ //test for three in a row
			if((board[x][y+3].played && ((board[x][y+3].color) == color))){ //test for four in a row
				if((board[x][y+4].played && ((board[x][y+4].color) == color))){ //test for five in a row
					white5Runs+=1;
				}
				else{
					white4Runs+=1;
				}
			}
			else{
				white3Runs+=1;
			}
		}
		if((board[x+1][y+1].played && ((board[x+1][y+1].color) == color)) && board[x+2][y+2].played && ((board[x+2][y+2].color) == color)){ //test for three in a row
			if((board[x+3][y+3].played && ((board[x+3][y+3].color) == color))){ //test for four in a row
				if((board[x+4][y+4].played && ((board[x+4][y+4].color) == color))){ //test for five in a row
					white5Runs+=1;
				}
				else{
					white4Runs+=1;
				}
			}
			else{
				white3Runs+=1;
			}
		}
		
		if((board[x-1][y+1].played && ((board[x-1][y+1].color) == color)) && board[x-2][y+2].played && ((board[x-2][y+2].color) == color)){ //test for three in a row
			if((board[x-3][y+3].played && ((board[x-3][y+3].color) == color))){ //test for four in a row
				if((board[x-4][y+4].played && ((board[x-4][y+4].color) == color))){ //test for five in a row
					white5Runs+=1;
				}
				else{
					white4Runs+=1;
				}
			}
			else{
				white3Runs+=1;
			}
		}
	})
	pieces[1].forEach(element =>{ //calculates runs for black
		let x = element.x + boardPadding;
		let y = element.y + boardPadding;
		let color = element.color;
				if((board[x+1][y].played && ((board[x+1][y].color) == color)) && board[x+2][y].played && ((board[x+2][y].color) == color)){ //test for three in a row
					if((board[x+3][y].played && ((board[x+3][y].color) == color))){ //test for four in a row
						if((board[x+4][y].played && ((board[x+4][y].color) == color))){ //test for five in a row
					black5Runs+=1;
				}
				else{
					black4Runs+=1;
				}
			}
			else{
				black3Runs+=1;
			}
		}
		if((board[x][y+1].played && ((board[x][y+1].color) == color)) && board[x][y+2].played && ((board[x][y+2].color) == color)){ //test for three in a row
			if((board[x][y+3].played && ((board[x][y+3].color) == color))){ //test for four in a row
				if((board[x][y+4].played && ((board[x][y+4].color) == color))){ //test for five in a row
					black5Runs+=1;
				}
				else{
					black4Runs+=1;
				}
			}
			else{
				black3Runs+=1;
			}
		}
		if((board[x+1][y+1].played && ((board[x+1][y+1].color) == color)) && board[x+2][y+2].played && ((board[x+2][y+2].color) == color)){ //test for three in a row
			if((board[x+3][y+3].played && ((board[x+3][y+3].color) == color))){ //test for four in a row
				if((board[x+4][y+4].played && ((board[x+4][y+4].color) == color))){ //test for five in a row
					black5Runs+=1;
				}
				else{
					black4Runs+=1;
				}
			}
			else{
				black3Runs+=1;
			}
		}
		
		if((board[x-1][y+1].played && ((board[x-1][y+1].color) == color)) && board[x-2][y+2].played && ((board[x-2][y+2].color) == color)){ //test for three in a row
			if((board[x-3][y+3].played && ((board[x-3][y+3].color) == color))){ //test for four in a row
				if((board[x-4][y+4].played && ((board[x-4][y+4].color) == color))){ //test for five in a row
					black5Runs+=1;
				}
				else{
					black4Runs+=1;
				}
			}
			else{
				black3Runs+=1;
			}
		}
	})
	return([[white3Runs,white4Runs,white5Runs],[black3Runs,black4Runs,black5Runs]]);
}
function drawBoard(board, size, rows, pieces){
		board.beginPath();
		board.clearRect(0,0,size,size)
		for(let x = 1;x<=rows;x+=1){
			board.moveTo(0,x*(size/rows))
			board.lineTo(size,x*(size/rows))
			board.stroke();
			board.moveTo(x*(size/rows),0)
			board.lineTo(x*(size/rows),size)
			board.stroke();		
		}
		//console.log("Board drawn.")
		//console.log(pieces[0].length)
		pieces[0].forEach(element=>{
		//alert(test)
		x = element.x;
		y = element.y;
		//console.log(x + ", " + y)
	
		context.beginPath();
		context.arc((x)*(size/rows),(y)*(size/rows),((size/rows)/2)-1,0,2*Math.PI);
		context.fillStyle = "#0000FF"; //make this selectable later
		context.fill();
		context.font ="24px Arial";
		context.fillStyle = "#FF0000";
		let offset = element.turn.toString().length*6;
		context.fillText(element.turn,(x)*(size/rows)-offset,(y)*(size/rows)+6);
		

		})
		
		pieces[1].forEach(element=>{
		x = element.x;
		y = element.y;
		context.beginPath();
		context.arc((x)*(size/rows),(y)*(size/rows),((size/rows)/2)-1,0,2*Math.PI);
		context.fillStyle = "#FF0000"; //make this selectable later
		context.fill();
		context.font = "24px Arial";
		context.fillStyle = "#0000FF";
		let offset = element.turn.toString().length*6;
		context.fillText(element.turn,(x)*(size/rows)-offset,(y)*(size/rows)+6);
		
		})
		
		//console.log("drawBoard completed")
	}

function place(e, NewGame){
try{
	//alert(NewGame.constructor.name)
	//alert(NewGame.rows)
	let size = NewGame.size
	let rows = NewGame.rows
	
	var pos = getMousePos(canvas, e);
    posx = pos.x; //objective x and y within the canvas	
    posy = pos.y;
	coordx = Math.floor(Math.roundTo(posx,(size/rows))/(size/rows)); //posx rounded down to the nearest multiple of cell size divided by cell size, this gives the coordinate cell
	coordy = Math.floor(Math.roundTo(posy,(size/rows))/(size/rows));
	NewGame.play(coordx,coordy)
	//console.log(coordx + ", " + coordy)
	
	}
	catch(x){
		//console.log(x)
	}
	

	/*
	var pos = getMousePos(canvas, e);
    posx = pos.x; //objective x and y within the canvas
    posy = pos.y;
	cellx = Math.floor(Math.roundDownTo(posx,(1000/19))/(1000/19)); //posx rounded down to the nearest multiple of cell size divided by cell size, this gives the coordinate cell
	celly = Math.floor(Math.roundDownTo(posy,(1000/19))/(1000/19));
	document.getElementById("EventBox").innerHTML = "Click came from inside cell: " + cellx + "," + celly;
	context.beginPath();
	context.arc((cellx)*(1000/19)+((1000/19)/2),(celly)*(1000/19)+((1000/19)/2),((1000/19)/2)-1,0,2*Math.PI);
	context.fill();
	*/
}

function draw(e) {
    var pos = getMousePos(canvas, e);
    posx = pos.x;
    posy = pos.y;
    context.fillStyle = "#000000";
    context.fillRect(posx, posy, 1, 1);
}
//window.addEventListener('mousemove', draw, false);

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,
        y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height
    };
}


if(typeof Math.roundDownTo === "undefined") {
Math.roundDownTo = function(num, step) {
return Math.floor((num / step)) * step;
}
}
if(typeof Math.roundTo === "undefined") {
Math.roundTo = function(num, step) {
return Math.floor((num / step) + 0.5) * step;
}
}
</script>